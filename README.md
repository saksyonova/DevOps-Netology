# DevOps-Netology
ДЗ "Работа в терминале 2":

1. type -a cd
cd - это встроенная в оболочку команда, меняет текущий каталог только для оболочки, в которой выполняется.
теоретически, ничто не мешает исполнителю shell реализовать её, как внешнюю команду, но работать она будет со своим окружением, и менять каталог внутри уже своего окружения, а на shell, вызвавший её, влиять не будет.

2. grep <some_string> <some_file> | wc -l
альтернатива: grep <some_string> <some_file> -c

3. pstree -p
родительский процесс с PID(1) - это процесс systemd.

4. открываем две сессии: /dev/pts/0 и /dev/pts/1
vagrant@vagrant:/dev/pts$ who
vagrant  pts/0        2021-11-15 16:20 (10.0.2.2)
vagrant  pts/1        2021-11-15 17:56 (10.0.2.2)

выполняя действия в первой сессии, выполняем "ls %" и ошибку выводим во вторую сессию:
vagrant@vagrant:~$ ls % 2>/dev/pts/1
в первой сессии ничего не происходит, зато во второй вывелась ошибка, которую и ожидали:
vagrant@vagrant:~$ ls: cannot access '%': No such file or directory

5. передаём одновременно команде файл на stdin (test_2) и сразу выводим её stdout в другой файл (test_3): 
vagrant@vagrant:~$ cat >> test_2
new lines here
vagrant@vagrant:~$ cat test_2
new lines here
vagrant@vagrant:~$ cat test_3
cat: test_3: No such file or directory
vagrant@vagrant:~$ cat <test_2 >test_3
vagrant@vagrant:~$ cat test_3
new lines here

6. просмотреть выводимые данные возможно только в случае непосредственного подключения к tty. удалось это сделать через Oracle VM VBox.
проверяем подключения в shell:
vagrant@vagrant:~$ who
vagrant  tty1         2021-11-15 20:43
vagrant  pts/0        2021-11-15 20:42 (10.0.2.2)

выводим что-нибудь в tty1:
vagrant@vagrant:~$ echo hey you >/dev/tty1
в окне tty1 видим:
vagrant@vagrant:~$ hey you

7. bash 5>&1 создаёт декскриптор (5) и перенаправляет его в stdout (1).
echo netology > /proc/$$/fd/5 выведет netology в дескриптор 5, который был перенаправлен в stdout.
если бы мы просто выполнили сначала echo netology > /proc/$$/fd/5 (или в новой сессии), то получили бы ошибку, так как такого дескриптора на данный момент нет:
vagrant@vagrant:~$ echo netology > /proc/$$/fd/5
-bash: /proc/1360/fd/5: No such file or directory

8. попробуем вывести и перенаправить вывод ошибки при выполнении "ls %", а также посчитаем, сколько раз встретится нам слово "access" (проверим на дублирование/потерю инфы):
vagrant@vagrant:~$ ls % 6>&2 2>&1 1>&6 | grep cannot -c
1
6>&2 - новый дескриптор перенаправили в stderr (2); 
2>&1 - stderr (2) перенаправили в stdout (1);
1>&6 - stdout (1) перенаправили в новый дескриптор.

9. cat /proc/$$/environ выведет информацию о переменных окружения.
более структурировано можно посмотреть через printenv или env.

10. /proc/[pid]/cmdline - полная командная строка запуска процесса, кроме тех процессов, которые стали зомби;
/proc/[pid]/exe - фактическое полное имя выполняемого файла. конечно, может использоваться обычным образом - открывать исполняемые файлы.

11. grep sse /proc/cpuinfo
кажется, SSE4_2.

12. сообщение "not a tty" возникает потому, что при подключении ожидается пользователь, а не другой процесс. для запуска можно указать -t и команда принудительно создаёт pty.

13. reptyr сначала не была даже установлена, исправляем:
sudo apt-get update
sudo apt-get install reptyr

vagrant@vagrant:~$ ps -a
   PID TTY          TIME CMD
   1301 pts/1    00:00:00 bash
   1584	pts/2	 00:00:00 screen
   1667 pts/3    00:00:00 top
   2144	pts/4	 00:00:00 ps
   
удалось перехватить через sudo reptyr -T 1667.

14. команда tee выводит одновременно и в файл, указанный в качестве параметра, и в stdout. в данном примере команда получает вывод из stdin, перенаправленный через pipe, от stdout команды echo. и так как команда запущена от sudo, имеет права на запись в файл.